# -*- coding: utf-8 -*-
"""scRNA-seq data analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1w2gFEQeBIW4Bf5DbbuN3_14OdDmsV1iU

# scRNA-seq Analysis of a Human Blood-Derived Immune Cell Dataset

## 1. Overview

This project implements an end-to-end single-cell RNA-seq (scRNA-seq) analysis workflow in Python using Scanpy.  
The analysis starts from a count matrix stored in an `.h5ad` file (`bone_marrow.h5ad`) and performs:

- Quality control (QC) and doublet detection
- Normalization and log-transformation
- Highly variable gene (HVG) selection
- Dimensionality reduction (PCA, UMAP)
- Graph-based clustering (Leiden)
- Cell-type scoring using decoupler and PanglaoDB marker signatures
- Manual cluster annotation and biological interpretation

Although the file is named `bone_marrow.h5ad`, the final cell-type composition is more consistent with a **blood-derived immune cell dataset (PBMC-like / peripheral blood leukocytes)** than classical bone marrow. The analysis therefore serves two purposes:

1. Provide a clean, reusable scRNA-seq analysis pipeline.
2. Infer and justify the underlying tissue/source from the resulting cellular landscape.

---

## 2. Environment and Installation

### 2.1. Requirements

Core Python packages:

- `scanpy`
- `anndata`
- `pandas`
- `numpy`
- `scipy`
- `matplotlib`
- `seaborn`
- `decoupler`
- `scrublet`
- `igraph`            (backend for Leiden clustering)
- `celltypist`        (optional, alternative annotation)
- `fa2-modified`      (optional, for graph layouts)



###2.2. Setup

#### Create and activate a virtual environment (optional but recommended)
    python -m venv .venv
    source .venv/bin/activate    # Linux/macOS
    # .venv\Scripts\activate      # Windows

#### Install dependencies
pip install -r requirements.txt
Once installed, open and run the notebook:
scRNA_seq_data_analysis_Lavinia2.ipynb

----

## 3. Data

###3.1. Input format
The workflow expects a single AnnData object in .h5ad format:

     bone_marrow.h5ad

Content:
    
    .X: raw counts (cells × genes), or raw counts in .layers["counts"]
    .obs: per-cell metadata (will be augmented by QC, doublet scores, clusters, etc.)
    .var: per-gene metadata, including a gene symbol column (e.g. gene_symbols or feature_name)

###3.2. Important note on dataset naming
Despite the filename, the analysis shows that the sample behaves more like a peripheral blood / PBMC immune dataset than canonical bone marrow. This conclusion is based on:

- Observed cell-type composition
- Lack of strong stem/progenitor and erythroid compartments
- Agreement with known PBMC scRNA-seq profiles

This is documented in the Findings section below.

---

## 4. Analysis Workflow
This section summarizes the complete scRNA-seq analysis pipeline implemented in the notebook.

###4.1. Data loading and identifier standardization
Load the count matrix as an AnnData object from bone_marrow.h5ad using scanpy.read_h5ad.

Ensure unique gene and cell identifiers:
    adata.var_names_make_unique()
    adata.obs_names_make_unique()

Why it matters:
Non-unique cell or gene identifiers break indexing and downstream operations. Standardizing names is required for a robust, reproducible pipeline.


###4.2. Gene-level QC flags and per-cell QC metrics
Select a gene symbol column from .var (e.g. gene_symbols or feature_name) and convert to upper case.

Define gene categories:
- Mitochondrial genes: symbols starting with MT-
- Ribosomal genes: symbols starting with RPS or RPL
- Hemoglobin genes: predefined list, e.g. HBA1, HBA2, HBB, HBD, HBG1, HBG2

Compute per-cell QC metrics using:

    sc.pp.calculate_qc_metrics(
    adata,
    qc_vars=['MT', 'RIBO', 'HB'],
    inplace=True
        )

This produces, among others:

    n_genes_by_counts
    total_counts
    pct_counts_MT
    pct_counts_RIBO
    pct_counts_HB (if hemoglobin genes are present)

Why it matters:
These metrics identify low-quality cells (few genes, low counts, high mitochondrial percentage) and potential technical biases that should be removed before clustering.

###4.3. Doublet detection with Scrublet

    Extract raw counts from .X or .layers["counts"].

Run Scrublet:

    scrub = scr.Scrublet(counts_matrix, expected_doublet_rate=0.06)
    doublet_scores, predicted_doublets = scrub.scrub_doublets()

Store results in per-cell metadata:

    adata.obs['doublet_score'] = doublet_scores
    adata.obs['predicted_doublet'] = predicted_doublets

Why it matters:

Doublets (two cells in one droplet) produce hybrid expression profiles and can form artificial “mixed” clusters, especially at higher resolution. Flagging or removing them improves cluster purity and interpretability.

###4.4. Cell-level QC filtering
Define thresholds based on QC plots (violins, scatterplots):

Examples (to be tuned to the dataset):

- n_genes_by_counts: minimum and maximum range (e.g. 200–5000)
- total_counts: minimum and maximum range (e.g. 500–50,000)
- pct_counts_MT: maximum allowed mitochondrial percentage (e.g. ≤ 20%)

Construct a boolean mask:

    cell_mask = (
      (adata.obs['n_genes_by_counts'] >= MIN_GENES) &
      (adata.obs['n_genes_by_counts'] <= MAX_GENES) &
     (adata.obs['total_counts'] >= MIN_COUNTS) &
     (adata.obs['total_counts'] <= MAX_COUNTS) &
      (adata.obs['pct_counts_MT'] <= MAX_MT)
    )

Subset the object:

    adata = adata[cell_mask].copy()

Optionally remove doublets:

    adata = adata[adata.obs['predicted_doublet'] == False].copy()

Why it matters:
Filtering ensures the downstream analysis is performed on high-quality singlet cells, reducing noise and artifactual structure.

###4.5. Normalization, log-transform, and highly variable genes (HVGs)

Save raw counts for reference:

    adata.layers['counts'] = adata.X.copy()

Normalize and log-transform:

    sc.pp.normalize_total(adata, target_sum=1e4)
    sc.pp.log1p(adata)

Identify highly variable genes:

    sc.pp.highly_variable_genes(adata, n_top_genes=2000, flavor='seurat_v3')
    adata = adata[:, adata.var['highly_variable']].copy()

Why it matters:
Normalization and log-transformation stabilize the variance structure, while restricting to HVGs focuses the analysis on informative genes and improves downstream dimensionality reduction and clustering.

###4.6. PCA, neighborhood graph, UMAP, and Leiden clustering

Run PCA on the HVG expression matrix:

    sc.tl.pca(adata, svd_solver='arpack')

Construct a k-nearest neighbor graph:

    sc.pp.neighbors(adata, n_neighbors=15, n_pcs=30, random_state=0)

Compute UMAP embedding:

    sc.tl.umap(adata, random_state=0)

Run Leiden clustering at one or more resolutions (e.g. 0.02, 0.5, 2.0):

    sc.tl.leiden(adata, resolution=0.5, key_added='leiden_res0_5')

Why it matters:
PCA and neighbors capture the main structure of variation. UMAP provides a 2D visualization of this manifold, and Leiden clustering identifies transcriptionally similar cell groups (candidate cell types or states).

###4.7. Cell-type scoring with decoupler and PanglaoDB

Retrieve PanglaoDB marker signatures via decoupler.

Convert the marker table into a network format with columns:
- source: cell type
- target: gene symbol

Run the ULM method:

    dc.mt.ulm(data=adata, net=markers, tmin=3)

This stores per-cell activity scores for each cell-type signature in adata.obsm ['score_ulm'].

Aggregate scores at cluster level using dotplots or matrixplots to see which signatures dominate each Leiden cluster.

Why it matters:
Cell-type scoring provides a reference-based, quantitative measure of how strongly each cell or cluster matches known cell-type programs (e.g. neutrophils, monocytes, B cells, T/NK cells), instead of relying on a few manually chosen markers.

###4.8. Differential expression and marker-based validation
Use sc.tl.rank_genes_groups to find marker genes per cluster.

Compare top-ranked genes with canonical lineage markers:
- Neutrophils (e.g. S100A8, S100A9, LST1)
- Monocytes/macrophages (myeloid markers)
- B cells (e.g. MS4A1, CD79A)
- T/NK cells (e.g. CD3D, TRAC, NKG7, GNLY)

Why it matters:
Differential expression validates cell-type assignments and refines cluster identities beyond what signature scoring alone can provide.

###4.9. Cluster annotation
Choose a main clustering resolution (e.g. leiden_res0_5).

Combine:
- decoupler-derived cell-type scores
- cluster-level marker genes
- known immunology of blood/bone marrow

Define a mapping:

    cluster_to_celltype = {
       "0": "Neutrophils",
      "1": "Monocytes / Macrophages",
      "2": "B cells",
      "3": "T / NK cells",
      "4": "Dendritic cells",
       "5": "Other / rare population",
    }
Apply it:

    adata.obs['cell_type'] = (
    adata.obs['leiden_res0_5'].map(cluster_to_celltype)
    ).astype('category')

Why it matters:
Cluster annotation translates numeric cluster IDs into interpretable biological populations, enabling comparison to external datasets and literature.

###4.10. Interpretation and dataset-type inference

Summarize the final composition of annotated cell types.

Compare the observed mixture to reference profiles of:
- Healthy bone marrow (HSPCs, erythroid progenitors, megakaryocytes, etc.)
- PBMC / peripheral blood (mature T, B, NK, monocytes, with minimal HSPCs/erythroid cells)
- Infer whether the dataset behaves like bone marrow, PBMC, or another immune compartment, and justify this with the observed distribution.

Why it matters:
Validating the dataset’s tissue-of-origin against known biology protects against mislabeled data and strengthens the interpretation of results.

---

##5. Findings and Interpretation

###5.1. QC and doublet detection

Low-quality cells were removed based on:
- Low and extremely high gene counts
- Low and extremely high total counts
- Elevated mitochondrial percentage

Scrublet identified a subset of cells with higher complexity and doublet-like expression; these were either removed or flagged during interpretation.

Conclusion:
The final dataset used for clustering and annotation consists of high-quality singlet cells, reducing technical noise and doublet artifacts.


###5.2. Global structure and clusters
UMAP and Leiden clustering at a chosen resolution (e.g. 0.5) revealed multiple transcriptionally distinct clusters.

These clusters correspond to major immune lineages, such as:

- Neutrophils
- Monocytes / macrophages
- Dendritic cells
- B cells
- T / NK cells
- Possibly small “other/rare” populations

Conclusion:
The dataset captures a diverse immune cell landscape characteristic of circulating or peripheral immune compartments.


###5.3. Cell-type annotation
decoupler + PanglaoDB signatures revealed strong matches for:

- Neutrophil signatures in specific clusters

- Monocyte/macrophage signatures in others

- B- and T/NK-cell signatures in lymphoid clusters

Differential expression confirmed these assignments with canonical markers.

Some myeloid clusters exhibited overlapping signatures (e.g. macrophages, dendritic cells, and tissue-macrophage-like labels such as “Kupffer cells” or “Microglia”). In this context, such labels were interpreted as macrophage-lineage transcriptional programs rather than true liver or brain tissue contamination.

Conclusion:
Clusters can be reliably annotated as neutrophils, monocytes/macrophages, dendritic cells, B cells, T/NK cells, and minor additional populations with mixed myeloid characteristics.


###5.4. Dataset type (bone marrow vs PBMC vs other source)
By comparing the annotated composition with known references:

- Expected in healthy bone marrow:
  - Prominent CD34+ hematopoietic stem and progenitor cell (HSPC) compartment
  - Multiple erythroid progenitor and maturation stages
  - Megakaryocyte / platelet lineages
  - Mixture of immature and mature immune cells

- Observed in this dataset:
  - Dominant populations of mature immune cells:
  - Neutrophils
  - Monocytes/macrophages
  - Dendritic cells
  - B cells
  - T/NK cells
  - Limited or no clear HSPC compartment
  - Limited erythroid progenitor representation and hemoglobin-heavy clusters
  - Typical for PBMC / peripheral blood:
  - Enrichment of mature T, B, NK cells and monocytes
  - Minimal HSPCs and erythroid lineage cells

- Interpretation:
  - Despite the file name bone_marrow.h5ad, the combination of:
    - Dominant mature lymphoid and myeloid populations,
    - Lack of strong stem/progenitor and erythroid compartments, and overall similarity to published PBMC / peripheral blood immune profiles, supports the conclusion that this dataset is best described as a blood-derived immune cell sample (PBMC-like / peripheral blood leukocytes) rather than classical bone marrow.
    *(Karolyn A. Oetjen, J. Philip McCoy, Christopher S. Hourigan. Human bone marrow assessment by single-cell RNA sequencing, mass cytometry, and flow cytometry  Published December 6, 2018. JCI Insight. 2018;3(23):e124928. https://doi.org/10.1172/jci.insight.124928.)*
   *( Xiaowei Xie, Mengyao Liu, Yawen Zhang, Bingrui Wang, Caiying Zhu, Chenchen Wang, Qing Li, Yingying Huo, Jiaojiao Guo, Changlu Xu, Linping Hu, Aiming Pang, Shihui Ma, Lina Wang, Wenbin Cao, Shulian Chen, Qiuling Li, Sudong Zhang, Xueying Zhao, Wen Zhou, Hongbo Luo, Guoguang Zheng, Erlie Jiang, Sizhou Feng, Lixiang Chen, Lihong Shi, Hui Cheng, Sha Hao, Ping Zhu, Tao Cheng, Single-cell transcriptomic landscape of human blood cells, National Science Review, Volume 8, Issue 3, March 2021, nwaa180, https://doi.org/10.1093/nsr/nwaa180)*
   *(Pellin, D., Loperfido, M., Baricordi, C. et al. A comprehensive single cell transcriptional landscape of human hematopoietic progenitors. Nat Commun 10, 2395 (2019). https://doi.org/10.1038/s41467-019-10291-0)*
   *(Oelen, R., de Vries, D.H., Brugge, H. et al. Single-cell RNA-sequencing of peripheral blood mononuclear cells reveals widespread, context-specific gene expression regulation upon pathogenic exposure. Nat Commun 13, 3267 (2022). https://doi.org/10.1038/s41467-022-30893-5)*


###5.5. Summary
A full scRNA-seq analysis pipeline was implemented, including QC, doublet detection, normalization, dimensionality reduction, clustering, and cell-type annotation.
The pipeline identified major immune cell populations and produced a coherent map of the sample’s immune composition.
Based on the cell-type landscape, the dataset is most consistent with a PBMC-like / peripheral blood leukocyte sample, not canonical bone marrow, illustrating the importance of validating metadata labels against biological evidence.

## scRNA-seq Analysis of a Human Blood-Derived Immune Cell Dataset

This notebook performs a full single-cell RNA-seq analysis workflow using Scanpy:
quality control (QC), doublet detection (Scrublet), normalization, dimensionality reduction,
clustering, cell-type annotation (using decoupler + PanglaoDB), and visualization.

The goal is to (1) produce a clean, reproducible analysis pipeline **and**
(2) infer the likely
tissue/source of the sample based on the resulting cell-type composition.

**Installations to set up Scanpy environment.**
"""

!pip install scanpy
!pip install anndata
!pip3 install igraph
!pip install celltypist
!pip install decoupler
!pip install fa2-modified

"""## 1. Load data & basic checks"""

#--1. Load data and standardize gene/cell names

import scanpy as sc
import anndata as ad

#Load pre-processed count matrix (cells x genes)
b_marrow_adata = sc.read_h5ad("/content/bone_marrow.h5ad")
print(b_marrow_adata)

# Exploration of dataset (shape of the anndata)
b_marrow_adata.shape

# Exploration of dataset (first five genes in the anndata)
b_marrow_adata.var.head()

# Exploration of dataset(first five cell data)
b_marrow_adata.obs.head()

# Exploration of dataset
b_marrow_adata.to_df()

"""## 2. Gene-level QC flags (MT, RIBO, HB)
Why: identify mitochondrial, ribosomal and hemoglobin genes for per-cell QC metrics.
"""

# Ensure unique gene and cell names (required by Scanpy)
b_marrow_adata.var_names_make_unique()
b_marrow_adata.obs_names_make_unique()

#--2 Flag mitochondrial, ribosomal and hemoglobin genes

#Mitochondrial genes: MT- prefix (human-style)
b_marrow_adata.var['MT'] = b_marrow_adata.var_names.str.startswith("MT-")

#Ribosomal: RPS* and RPL*
b_marrow_adata.var['RIBO'] = b_marrow_adata.var_names.str.startswith(("RPS", "RPL"))

 #Hemoglobin: selected known genes
hb_gene_list = ['HBA1', 'HBA2', 'HBB', 'HBD', 'HBG1', 'HBG2']
# Convert var_names to uppercase for case-insensitive comparison with hb_gene_list
sym_upper = b_marrow_adata.var_names.str.upper()
# Set 'HB' to True for genes whose uppercase names are in hb_gene_list
b_marrow_adata.var['HB'] = sym_upper.isin(hb_gene_list)

# Quick sanity check: how many genes in each category?
b_marrow_adata.var[['MT', 'RIBO', 'HB']].sum()

#Calculating QC metrics
sc.pp.calculate_qc_metrics(
    b_marrow_adata, qc_vars=["MT", 'RIBO', 'HB'], inplace=True, log1p=True
)
b_marrow_adata.obs.head()

b_marrow_adata.var.head()

"""## 3. Cell-level QC metrics & filtering
Why: remove low-quality cells and outliers (likely doublets / dying cells) before downstream analysis.
"""

# Basic gene/cell filters
sc.pp.filter_cells(b_marrow_adata, min_genes=200)
sc.pp.filter_genes(b_marrow_adata, min_cells=3)

# Mito threshold (tune based on plots)
b_marrow_adata = b_marrow_adata[b_marrow_adata.obs['pct_counts_MT'] < 20, :].copy()

b_marrow_adata = b_marrow_adata[b_marrow_adata.obs['pct_counts_RIBO'] < 20, :].copy()


b_marrow_adata = b_marrow_adata[b_marrow_adata.obs['pct_counts_HB'] < 20, :].copy()

#Average number of genes with at least one detected identifier in each cell
sc.pl.violin(
    b_marrow_adata,
    ["n_genes_by_counts"],
    jitter=0.4,
    multi_panel=False,
)

#Total number of molecules (UMI) detected in cell.
sc.pl.violin(
    b_marrow_adata,
    ["total_counts"],
    jitter=0.4,
    multi_panel=False,
)

#Visualization of mt genes
sc.pl.scatter(b_marrow_adata, "total_counts", "n_genes_by_counts", color="pct_counts_MT")

#visualization of ribosomal genes
sc.pl.scatter(b_marrow_adata, "total_counts", "n_genes_by_counts", color="pct_counts_RIBO")

#Visualization of HB genes
sc.pl.scatter(b_marrow_adata, "total_counts", "n_genes_by_counts", color="pct_counts_HB")

b_marrow_adata.obs.columns

"""## 4. Doublet detection with Scrublet
Why: identify droplets that likely contain more than one cell and could create artifactual clusters.

"""

#--- 3. Doublet detection with Scrublet on raw counts
!pip install scrublet

import scrublet as scr
import scipy.sparse as sp

sc.pp.scrublet(b_marrow_adata)

# ---------- Scrublet doublet detection ----------

# Use raw counts
if "counts" in b_marrow_adata.layers:
    counts_matrix = b_marrow_adata.layers["counts"]
else:
    counts_matrix = b_marrow_adata.X

# Convert to dense scrublet
if sp.issparse(counts_matrix):
    counts_matrix = counts_matrix.toarray()

#Initialize Scrublet with a reasonable expected doublet rate (~5-10%)
scrub = scr.Scrublet(
    counts_matrix,
    expected_doublet_rate=0.06  # 6% prior; fine for coursework unless told otherwise
)

# Compute pre-cell doublet scores and binary calls
doublet_scores, predicted_doublets = scrub.scrub_doublets()

# Store outputs in pre-cell metadata
b_marrow_adata.obs["doublet_score"] = doublet_scores
b_marrow_adata.obs["predicted_doublet"] = predicted_doublets

# Sanity check
b_marrow_adata.obs[["doublet_score", "predicted_doublet"]].head()

# Compare QC metrics between singlets and predicted doublets
b_marrow_adata.obs['predicted_doublet'] = b_marrow_adata.obs['predicted_doublet'].astype('category')
sc.pl.violin(
    b_marrow_adata,
    ["n_genes_by_counts", "total_counts"],
    groupby="predicted_doublet",
    multi_panel=True
)

# ---------- Filter out predicted doublets ----------

before = b_marrow_adata.n_obs
b_marrow_adata = b_marrow_adata[b_marrow_adata.obs["predicted_doublet"] == False].copy()
after = b_marrow_adata.n_obs

print(f"Removed {before - after} predicted doublets; remaining {after} cells.")

"""## 5. Normalization, log-transform and highly variable genes
Why: stabilize variance and focus on informative genes for downstream dimensionality reduction.
"""

#Save a copy of the bone marrow data
b_marrow_adata.layers["counts"] = b_marrow_adata.X.copy()

#Normalizing to median total counts
sc.pp.normalize_total(b_marrow_adata)
#Log of the data
sc.pp.log1p(b_marrow_adata)

#Selecting top 1000 most variable genes
sc.pp.highly_variable_genes(b_marrow_adata, n_top_genes=1000)

sc.pl.highly_variable_genes(b_marrow_adata)

"""## 6. PCA, neighborhood graph, UMAP and Leiden clustering
Why: embed cells into a low-dimensional manifold and identify transcriptionally similar groups.
"""

sc.tl.pca(b_marrow_adata)
sc.pl.pca_variance_ratio(b_marrow_adata, n_pcs=10, log=False)

sc.pl.pca(
    b_marrow_adata,
    color=["pct_counts_MT"]
)

sc.pp.neighbors(b_marrow_adata)
sc.tl.umap(b_marrow_adata)

sc.pl.umap(
    b_marrow_adata,
    color=["pct_counts_RIBO"],
    size=8,
)

sc.tl.leiden(b_marrow_adata, flavor="igraph", n_iterations=2)

sc.pl.umap(
    b_marrow_adata,
    color=["leiden"],
    size=8,
)

sc.pl.umap(
    b_marrow_adata,
    color=["leiden"],
    wspace=0.5,
    size=3,
    ncols = 1
)

b_marrow_adata.obs.columns

sc.pl.umap(b_marrow_adata, color=["leiden_res0_5", "doublet_score", "predicted_doublet"])

sc.tl.leiden(b_marrow_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_02", resolution=0.02)
sc.tl.leiden(b_marrow_adata, flavor="igraph", n_iterations=2, key_added="leiden_res0_5", resolution=0.5)
sc.tl.leiden(b_marrow_adata, flavor="igraph", n_iterations=2, key_added="leiden_res2", resolution=2)

sc.pl.umap(
    b_marrow_adata,
    color=["leiden_res0_02"],
    # increase horizontal space between panels
    wspace=0.5,
    size=15,
    ncols = 1
)

sc.pl.umap(
    b_marrow_adata,
    color=["leiden_res0_5"],
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

sc.pl.umap(
    b_marrow_adata,
    color=["leiden_res2"],
    wspace=0.5,
    size=15,
    ncols = 1,
    legend_loc="on data"
)

"""## 7. Cell-type scoring with decoupler (PanglaoDB)
Why: use reference marker signatures to quantify how “neutrophil-like”, “B cell-like”, etc. each cell is.
"""

import decoupler as dc

# Query Omnipath and get CellMarker
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format because dc only accepts cell_type and genesymbol

markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]


markers.tail()

# This line was causing an error and is not a valid operation for a pandas DataFrame.
# If you intended to remove the 'markers' variable from memory, you could use 'del markers'.
# markers.free()

import pandas as pd
import decoupler as dc

# Query Omnipath and get CellMarker
markers = dc.op.resource(name="PanglaoDB", organism="human")

# Keep canonical cell type markers alone
markers = markers[markers["canonical_marker"]]

# Remove duplicated entries
markers = markers[~markers.duplicated(["cell_type", "genesymbol"])]

# Format because dc only accepts cell_type and genesymbol
markers = markers.rename(columns={"cell_type": "source", "genesymbol": "target"})
markers = markers[["source", "target"]]

# Convert 'feature_name' column to a plain Index of strings before assigning to var_names
b_marrow_adata.var_names = pd.Index(b_marrow_adata.var['feature_name'].astype(str))
b_marrow_adata.var_names_make_unique()

dc.mt.ulm(data=b_marrow_adata,
          net=markers,
          tmin = 3)

import pandas as pd
import decoupler as dc

# retrieve the score for each cell type
score = dc.pp.get_obsm(b_marrow_adata, key="score_ulm")

sc.pl.dotplot(
    score, # Use the 'score' AnnData object directly
    var_names=score.var_names.tolist(), # List of cell types (features)
    groupby='leiden_res0_5',
    cmap='RdBu_r', # A common colormap for scores
    dendrogram=True,
    standard_scale='var', # Scale scores for better visualization
    title='Cell Type Scores by Leiden Clusters'
)

#retrieve the score for each cell type

score = dc.pp.get_obsm(b_marrow_adata, key="score_ulm")
score

#preview the data
b_marrow_adata.obsm["score_ulm"].head()

b_marrow_adata.obsm["score_ulm"].columns

sc.pl.umap(score, color=["NK cells", "leiden_res2"], cmap="RdBu_r")

sc.pl.umap(score, color=["NK cells", "leiden_res0_5"], cmap="RdBu_r")

"""## 8. Cluster annotation and visualization
Why: assign human-readable cell-type labels to clusters and interpret the cellular composition.
"""

# Get cell-type scores as DataFrame
score = dc.pp.get_obsm(b_marrow_adata, key="score_ulm")

#Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res2",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

# Keep only positive stats (enriched vs rest)
rank_df = rank_df[rank_df["stat"] > 0]

#Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

b_marrow_adata.obs["cell_type"] = (
    b_marrow_adata.obs["leiden_res2"].map(cluster_auto)
).astype("category")

sc.pl.umap(b_marrow_adata, color=["cell_type"], legend_loc="on data")



# 1. Get cell-type scores as DataFrame
score = dc.pp.get_obsm(b_marrow_adata, key="score_ulm")

# 2. Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res0_02",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

# Keep only positive stats (enriched vs rest)
rank_df = rank_df[rank_df["stat"] > 0]

# 3. Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

b_marrow_adata.obs["cell_type_auto"] = (
    b_marrow_adata.obs["leiden_res0_02"].map(cluster_auto)
).astype("category")

sc.pl.umap(b_marrow_adata, color=["cell_type_auto"], legend_loc="on data")

# Get cell-type scores as DataFrame
score = dc.pp.get_obsm(b_marrow_adata, key="score_ulm")

# 2. Rank signatures per cluster for your main clustering
rank_df = dc.tl.rankby_group(
    score,
    groupby="leiden_res0_5",  # use the same clustering
    reference="rest",
    method="t-test_overestim_var",
)

# Keep only positive stats (enriched vs rest)
rank_df = rank_df[rank_df["stat"] > 0]

# Take top signature per cluster
cluster_auto = (
    rank_df
    .sort_values(["group", "stat"], ascending=[True, False])
    .groupby("group")
    .head(1)
    .set_index("group")["name"]   # 'name' = signature (e.g. "Neutrophils")
    .to_dict()
)

cluster_auto

b_marrow_adata.obs["cell_type_auto"] = (
    b_marrow_adata.obs["leiden_res0_5"].map(cluster_auto)
).astype("category")

sc.pl.umap(b_marrow_adata, color=["cell_type_auto"], legend_loc="on data")

import seaborn as sns

sc.pl.violin(score, keys=["Neutrophils"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["NK cells"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["Plasma cells"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["B cells naive"], groupby="leiden_res0_5", rotation=90)

sc.pl.violin(score, keys=["Nuocytes"], groupby="leiden_res0_5", rotation=90)

#rank genes
b_marrow_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_02", reference="rest", method="t-test_overestim_var")
b_marrow_adata_rank = b_marrow_adata_rank[b_marrow_adata_rank["stat"] > 0]

#rank genes
b_marrow_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res0_5", reference="rest", method="t-test_overestim_var")
b_marrow_adata_rank = b_marrow_adata_rank[b_marrow_adata_rank["stat"] > 0]
b_marrow_adata_rank.head()

#rank genes
b_marrow_adata_rank = dc.tl.rankby_group(score, groupby="leiden_res2", reference="rest", method="t-test_overestim_var")
b_marrow_adata_rank = b_marrow_adata_rank[b_marrow_adata_rank["stat"] > 0]
b_marrow_adata_rank.head()

cluster_annotations = b_marrow_adata_rank[b_marrow_adata_rank["stat"] > 0].groupby("group").head(1).set_index("group")["name"].to_dict()

cluster_annotations

b_marrow_adata.obs['cell_type'] = b_marrow_adata.obs['leiden_res0_02'].map(cluster_annotations)

b_marrow_adata.obs['cell_type'] = b_marrow_adata.obs['leiden_res0_5'].map(cluster_annotations)

b_marrow_adata.obs['cell_type'] = b_marrow_adata.obs['leiden_res2'].map(cluster_annotations)

# Example of how to subset for multiple genes in the 'source' column
available_genes = set(b_marrow_adata.var_names)

neutro_markers = markers[markers['source'].isin(['Neutrophils'])]['target']
neutro_markers = neutro_markers[neutro_markers.isin(available_genes)]

macro_markers = markers[markers['source'].isin(['Macrophages'])]['target']
macro_markers = macro_markers[macro_markers.isin(available_genes)]

den_cells_markers = markers[markers['source'].isin(['Dendritic cells'])]['target']
den_cells_markers = den_cells_markers[den_cells_markers.isin(available_genes)]

kup_cells_markers = markers[markers['source'].isin(['Kupffer cells'])]['target']
kup_cells_markers = kup_cells_markers[kup_cells_markers.isin(available_genes)]

micro_markers = markers[markers['source'].isin(['Microglia'])]['target']
micro_markers = micro_markers[micro_markers.isin(available_genes)]

marker_genes_dict = {
    "Neutrophils":neutro_markers.head().tolist(),
    "Macrrophages": macro_markers.head().tolist(),
    "Dendritic cells": den_cells_markers.head().tolist(),
     "Kupffer cells": kup_cells_markers.head().tolist(),
     "Microglia": micro_markers.head().tolist()
}

sc.tl.dendrogram

sc.tl.dendrogram(b_marrow_adata, groupby="leiden_res0_5")
sc.pl.matrixplot(
    b_marrow_adata,
    marker_genes_dict,
    "leiden_res0_5",
    dendrogram=True,
    cmap="Greens",
    use_raw=False
)

sc.tl.dendrogram(b_marrow_adata, groupby="leiden_res0_02")
sc.pl.matrixplot(
    b_marrow_adata,
    marker_genes_dict,
    "leiden_res0_02",
    dendrogram=True,
    cmap="Blues",
    use_raw=False
)

sc.tl.dendrogram(b_marrow_adata, groupby="leiden_res2")
sc.pl.matrixplot(
    b_marrow_adata,
    marker_genes_dict,
    "leiden_res2",
    dendrogram=True,
    cmap="Reds",
    use_raw=False
)

sc.pl.tracksplot(b_marrow_adata, marker_genes_dict, groupby="leiden_res2", dendrogram=False, use_raw=False)

b_marrow_adata.var.index = b_marrow_adata.var.index.astype(str)
b_marrow_adata.var_names_make_unique()
sc.pl.tracksplot(b_marrow_adata, marker_genes_dict, groupby="leiden_res0_5", dendrogram=False, use_raw=False)

b_marrow_adata.var.index = b_marrow_adata.var.index.astype(str)
b_marrow_adata.var_names_make_unique()
sc.pl.tracksplot(b_marrow_adata, marker_genes_dict, groupby="leiden_res0_02", dendrogram=False, use_raw=False)

